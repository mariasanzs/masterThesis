/*
 * Copyright 2020 CoÃ¶peratieve Rabobank U.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as chai from 'chai'
import {
  IVerifiableCredentialParams,
  IVerifiablePresentationParams,
  VerifiableCredential,
  VerifiablePresentation
} from 'vp-toolkit-models'
import { LocalCryptUtils } from 'crypt-util'
import { VerifiableCredentialSigner, VerifiablePresentationGenerator, VerifiablePresentationSigner } from '../../src'

const accountId = 0
const keyId = 0
const issuerKeys = {
  privKey: 'xprv9s21ZrQH143K3T7143BKMvxoLpFzUkoyU7sQS7iQ88FVGatVTvFe1sKU1Vvysj378AAvvTyjziPZ6AisTNV7uC9irDHEnxZqGYpeceP1S6c',
  pubKey: '58ffea3c24293e9939823b165a7e9c565077e2458e823a396bdcafa65a4b1e768463a4a80aaa76c15848a4c9c16ff19361ef529cd7b890748fc717a82afe6aae',
  address: '0xc62CE67381C12615e0b88FF8dD001609926498b8'
}
const holderKeys = { // Always generated as DID by the holder
  privKey: 'xprv9s21ZrQH143K2xcKPR8Z6GDyvxSRY2FpGNhwmpPcoJKZ3BaeVbixKaoEMAUTBQkjqnmFJXGwQuktCwNVrXUBLvLgjwK5iym9keD3FJN2RdC',
  // Addresses below derived from the privkey by using accountId 0 and keyId 1,2 and 3.
  pubKey1: '5945c17dd10f13b0a6b860e6a6cc5ada7496f7718e9fef2bc31e6811d7c0a50491703adf65de62a5177b8812af5bb57586c4751e0ff2b6a7aa7d3c1dee48c670',
  address1: '0x47b7b31b9346fBb4C960DA804250cD9619b3b704',
  pubKey2: '9c9e2033483d66f3c04f89c017ff0b946a74815213adf580e4eb737f5813d8230799e1351ad60157b880c08d81bef975a363106ef0105e7c602b8206bcfbfe1a',
  address2: '0xfCe1EB2147504E2eCA113964042Ba484BDfE70b8',
  pubKey3: 'c71c4c2536243b3164cb1fef0e574b66252c18397a2cd085c98baf8115df2bf3ee0656968a6d52e31eb28bb9259d44b97e9ddd6fea8a1308d3104aad314565b7',
  address3: '0xa1800B6ab39623f2f63664fe6902aB26261A614a'
}

// The self-signed credential using the variables above
const selfSignedVcParams = {
  id: 'did:protocol:address',
  type: ['VerifiableCredential', 'DidOwnership'],
  issuer: 'did:eth:' + holderKeys.address1,
  issuanceDate: new Date('2019-01-01T23:34:45.000Z'),
  credentialSubject: { id: 'did:eth:' + holderKeys.address1 },
  proof: {
    type: 'secp256k1Signature2019',
    created: new Date('2019-07-30T09:51:27.589Z'),
    verificationMethod: holderKeys.pubKey1,
    nonce: 'deebe007-ab09-4893-a3be-f47b465edd8c',
    signatureValue:
      'f01a941fbdad053b950233add21d3f175c0f9e4542749e8e1f44dba83bab37b513e760d4f39d212fa2b54aec32e051ef0bf797d01c38f5085f57054efc9bdb91'
  },
  credentialStatus: {
    type: 'vcStatusRegistry2019',
    id: holderKeys.address1
  },
  '@context': undefined
}

// VP containing one self-attested credential
const selfSignedVpParams: IVerifiablePresentationParams = {
  id: 'urn:uuid:b6c9e11b-97ff-414f-99a2-e88cf4b6245e',
  type: ['VerifiablePresentation'],
  verifiableCredential: [new VerifiableCredential(selfSignedVcParams)]
}

// Credential generated by a third party
const issuerVcParams: IVerifiableCredentialParams = {
  id: 'did:protocol:address',
  type: ['VerifiableCredential'],
  issuer: 'did:eth:' + issuerKeys.address,
  issuanceDate: new Date(Date.UTC(2019, 0, 1, 23, 34, 56)),
  credentialSubject: {
    id: 'did:eth:' + holderKeys.address2,
    type: 'John'
  },
  proof: {
    type: 'secp256k1Signature2019',
    created: new Date(Date.UTC(2019, 6, 30, 9, 8, 49, 665)),
    verificationMethod: issuerKeys.pubKey,
    nonce: '62a7c7e6-b025-4e00-8956-c3859dacfe92',
    signatureValue:
      '83f0c76b3606b5ce95e37fa7f5becaf059cd5fe2bc08e133d019c585d2f995bb2fdcf1df3ef82dcae1c5478a4f4d7c36942b5d79338f3af37df1917c7c9c9937'
  },
  credentialStatus: {
    type: 'vcStatusRegistry2019',
    id: issuerKeys.address
  },
  '@context': ['https://schema.org/givenName']
}

// VP containing one issuer credential and one self-attested credential
const mixedVpParams: IVerifiablePresentationParams = {
  id: 'urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5',
  type: ['VerifiablePresentation'],
  verifiableCredential: [new VerifiableCredential(selfSignedVcParams), new VerifiableCredential(issuerVcParams)]
}

// Malicious VP
const maliciousVpParams: IVerifiablePresentationParams = {
  id: 'urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5',
  type: ['VerifiablePresentation'],
  verifiableCredential: [new VerifiableCredential(issuerVcParams)],
  proof: [
    {
      type: 'secp256k1Signature2019',
      created: new Date('2020-02-26T14:42:15.880Z'),
      verificationMethod: '3340a4c70c5d95df926d89b6ad9d5924d446c3facd3b99e41dd4a4439c39fd57b7c5947179f6af37f1d75430a6869d5e49de27531122051c59c0214978b92667',
      nonce: '2e4ecdc1-bbc2-42c3-9eac-948ce0ee4a39',
      signatureValue: '3488febdf11558e4f267943da4b8f8c643076d6a0a72db62371d77e5fbc300076b98222ef003be8e8710a93279987646f3231ddb8f9827642f1570c28dce1a1f'
    }
  ]
}

before(() => {
  chai.should()
})

describe('Integration: Verifiable presentation generator, stringify, parse and validate signature', function () {
  const cryptUtil = new LocalCryptUtils()
  cryptUtil.importMasterPrivateKey(holderKeys.privKey)
  const vcSigner = new VerifiableCredentialSigner(cryptUtil)
  const vpSigner = new VerifiablePresentationSigner(cryptUtil, vcSigner)
  const sut = new VerifiablePresentationGenerator(vpSigner)

  // A mixed VP contains self-attested credentials as well as issuer-attested credentials
  it('should generate, sign and then validate a mixed VP correctly', () => {
    const signedVp = sut.generateVerifiablePresentation(mixedVpParams, [
      { accountId: 0, keyId: 0 },
      { accountId: 0, keyId: 1 }
    ])
    const isValid = vpSigner.verifyVerifiablePresentation(signedVp)

    isValid.should.be.equal(true)
  })

  it('should fail verification if the credentialSubject.id did not create the proof', () => {
    const maliciousVP = new VerifiablePresentation(maliciousVpParams) // Signed with accountid and keyid 100, which does not corresponds to the VC
    const isValid = vpSigner.verifyVerifiablePresentation(maliciousVP)

    isValid.should.be.equal(false)
  })

  // A mixed VP contains self-attested credentials as well as issuer-attested credentials
  it('should generate, sign invalidly and then fail verification for a mixed VP', () => {
    const signedVp = sut.generateVerifiablePresentation(mixedVpParams, [{ accountId: accountId, keyId: keyId }])

    // Create invalid signature
    signedVp.proof[0].signatureValue = '9d967a97e935a17245593c0a4cd5faefa0b5282b9c46e0b358b05571211ddc5c775b0aa34fa4fc324acf029de20abeb2c47c3c72aa806025d75b672dfd2e16e1'

    const isValid = vpSigner.verifyVerifiablePresentation(signedVp)

    isValid.should.be.equal(false)
  })

  // A mixed VP contains self-attested credentials as well as issuer-attested credentials
  it('should generate, sign, stringify, parse and then validate a mixed VP correctly', () => {
    const signedVp = sut.generateVerifiablePresentation(mixedVpParams, [
      { accountId: 0, keyId: 0 },
      { accountId: 0, keyId: 1 }
    ])
    const stringifiedVp = JSON.stringify(signedVp)
    const parsedVp = new VerifiablePresentation(JSON.parse(stringifiedVp))

    const cryptUtilx = new LocalCryptUtils()
    const vcSignerx = new VerifiableCredentialSigner(cryptUtilx)
    const vpSignerx = new VerifiablePresentationSigner(cryptUtilx, vcSignerx)
    const isValid = vpSignerx.verifyVerifiablePresentation(parsedVp)

    isValid.should.be.equal(true)
  })

  // A self-signed VP contains only self-signed credentials
  it('should generate, sign and then validate correctly for a self-signed VP', () => {
    const signedVp = sut.generateVerifiablePresentation(selfSignedVpParams, [{
      accountId: accountId,
      keyId: keyId
    }])
    const isValid = vpSigner.verifyVerifiablePresentation(signedVp)

    isValid.should.be.equal(true)
  })

  it('should generate, sign and then not validate correctly for an incorrect self-signed VP', () => {
    const signedVp = sut.generateVerifiablePresentation(selfSignedVpParams, [{
      accountId: accountId,
      keyId: keyId
    }])
    // Create invalid signature
    signedVp.proof[0].signatureValue = '9d967a97e935a17245593c0a4cd5faefa0b5282b9c46e0b358b05571211ddc5c775b0aa34fa4fc324acf029de20abeb2c47c3c72aa806025d75b672dfd2e16e1'

    const isValid = vpSigner.verifyVerifiablePresentation(signedVp)

    isValid.should.be.equal(false)
  })

  it('should generate, sign, stringify, parse and then validate correctly for a self-signed VP', () => {
    const signedVp = sut.generateVerifiablePresentation(selfSignedVpParams, [{
      accountId: accountId,
      keyId: keyId
    }])
    const stringifiedVp = JSON.stringify(signedVp)
    const parsedVp = new VerifiablePresentation(JSON.parse(stringifiedVp))
    const isValid = vpSigner.verifyVerifiablePresentation(parsedVp)

    isValid.should.be.equal(true)
  })
})
